// Package icmppkt contains utilities for dealing with ICMP packets and ICMP
// errors.
package icmppkt

import (
	"fmt"
	"log"
	"syscall"

	"github.com/pcekm/graphping/internal/backend"
	"github.com/pcekm/graphping/internal/util"
	"github.com/pcekm/graphping/internal/util/udppkt"
	"golang.org/x/net/icmp"
	"golang.org/x/net/ipv4"
	"golang.org/x/net/ipv6"
)

const (
	codePortUnreachableV4 = 3
	codePortUnreachableV6 = 4
)

// Parse parses an ICMP packet.
func Parse(ipVer util.IPVersion, buf []byte) (pkt *backend.Packet, id int, err error) {
	rm, err := icmp.ParseMessage(ipVer.ICMPProtoNum(), buf)
	if err != nil {
		return nil, -1, fmt.Errorf("parsing message: %v", err)
	}

	switch rm.Type {
	case ipv4.ICMPTypeEcho, ipv4.ICMPTypeEchoReply, ipv6.ICMPTypeEchoRequest, ipv6.ICMPTypeEchoReply:
		return echoToPacket(rm)
	case ipv4.ICMPTypeDestinationUnreachable, ipv6.ICMPTypeDestinationUnreachable:
		return destUnreachableToPacket(ipVer, rm)
	case ipv4.ICMPTypeTimeExceeded, ipv6.ICMPTypeTimeExceeded:
		return timeExceededToPacket(ipVer, rm)
	default:
		return nil, -1, fmt.Errorf("unhandled ICMP type: %v", rm.Type)
	}
}

func echoToPacket(msg *icmp.Message) (*backend.Packet, int, error) {
	var packetType backend.PacketType
	switch msg.Type {
	case ipv4.ICMPTypeEcho, ipv6.ICMPTypeEchoRequest:
		packetType = backend.PacketRequest
	case ipv4.ICMPTypeEchoReply, ipv6.ICMPTypeEchoReply:
		packetType = backend.PacketReply
	default:
		log.Panicf("Unexpected ICMP message type: %v", msg.Type)
	}
	body := msg.Body.(*icmp.Echo)
	return &backend.Packet{
		Type:    packetType,
		Seq:     body.Seq,
		Payload: body.Data,
	}, body.ID, nil
}

func destUnreachableToPacket(ipVer util.IPVersion, msg *icmp.Message) (*backend.Packet, int, error) {
	body := msg.Body.(*icmp.DstUnreach)
	pkt, id, err := ipBodyToPacket(ipVer, body.Data)
	if err != nil {
		return nil, -1, err
	}
	portUnreachable := (ipVer == util.IPv4 && msg.Code == codePortUnreachableV4) || (ipVer == util.IPv6 && msg.Code == codePortUnreachableV6)
	if portUnreachable {
		// Generated by a UDP or TCP packet reaching a closed port on the
		// destination, so this is a successful reply from a ping standpoint.
		// The host was there and it answered.
		pkt.Type = backend.PacketReply
	} else {
		pkt.Type = backend.PacketDestinationUnreachable
	}
	return pkt, id, err
}

func timeExceededToPacket(ipVer util.IPVersion, msg *icmp.Message) (*backend.Packet, int, error) {
	body := msg.Body.(*icmp.TimeExceeded)
	pkt, id, err := ipBodyToPacket(ipVer, body.Data)
	if err != nil {
		return nil, -1, err
	}
	pkt.Type = backend.PacketTimeExceeded
	return pkt, id, err
}

func ipBodyToPacket(ipVer util.IPVersion, buf []byte) (*backend.Packet, int, error) {
	var proto, headerLen int
	switch ipVer {
	case util.IPv4:
		ipHeader, err := ipv4.ParseHeader(buf)
		if err != nil {
			return nil, -1, fmt.Errorf("parse header: %v", err)
		}
		proto = ipHeader.Protocol
		headerLen = ipHeader.Len
	case util.IPv6:
		ipHeader, err := ipv6.ParseHeader(buf)
		if err != nil {
			return nil, -1, fmt.Errorf("parse header: %v", err)
		}
		proto = ipHeader.NextHeader
		headerLen = ipv6.HeaderLen
	default:
		log.Panicf("Invalid ipVer: %v", ipVer)
	}

	switch proto {
	case ipVer.ICMPProtoNum():
		return Parse(ipVer, buf[headerLen:])
	case syscall.IPPROTO_UDP:
		return decodeUDP(buf[headerLen:])
	default:
		return nil, -1, fmt.Errorf("unrecognized proto field: %v", proto)
	}
}

// Decodes a UDP packet into a backend.Packet. The caller must set the Type
// field.
func decodeUDP(buf []byte) (*backend.Packet, int, error) {
	udph, err := udppkt.ParseUDPHeader(buf)
	if err != nil {
		return nil, -1, fmt.Errorf("parse UDP header: %v", err)
	}
	var payload []byte
	if len(buf) > udppkt.UDPHeaderLen {
		payload = buf[udppkt.UDPHeaderLen:]
	}
	return &backend.Packet{Seq: int(udph.DstPort), Payload: payload}, int(udph.SrcPort), nil
}
